<!DOCTYPE html>
<html>
	<head>
        
		<title>4D Chess</title>
		<!--	Disable Zoom on mobile	-->
		<meta name="viewport" content="width=device-width, user-scalable=no">
        
<!--        <script src="/socket.io/socket.io.js"></script>-->
        <script src="js/three.js"></script>
        <script src="js/TrackballControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/models.js"></script>
        <script src="js/GameBoard.js"></script>
		<script src="js/MoveManager.js"></script>
        <script src="js/Piece.js"></script>
        <script src="js/Pointer.js"></script>
        <script src="js/Animation.js"></script>
        
        <style>
            body {
                margin: 0px;
            }
        </style>
        
        <script>
//            try {
//				const socket = io()
//			socket.emit('HW message', 'hello from html!')
//			} catch(err) {
//				console.warn('Socket.io lib not found')
//			}
            
        
            // when the window loads, execute the function named 'init', which initalizes the simulation
            window.onload = function(){

                if(Detector.webgl){

                    Models.loadModels(); // Will call init function when finished

                } else {

                    var warning = Detector.getWebGLErrorMessage();
                    document.getElementById('container').appendChild(warning);

                }

            };

            // declare global variables
            let scene;
            let camera;
            let renderer;
            let controls;
            let gameBoard;
			let moveManager;
            let pointer;
            let animationQueue = []
			let debugSphere;

            function init(){
                initTHREE();
                initControls();
                initPointer();
                
                // begin the simulation loop
                requestAnimationFrame(frame);
				
				mayn();
            }

            //
            // Functionality provided by three.js:
            // 
            function initTHREE(){

                // Code from three.js scene creation example.
                // https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene
                scene = new THREE.Scene(); // Create new scene
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 9000); 
//                camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 9000); 
//                camera.position.set(510, 410, -525)
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                renderer.setClearColor(0xf7f7f7);
                // Code from three.js ambient light example:
                // https://threejs.org/docs/index.html#api/lights/AmbientLight
                let ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
                scene.add(ambientLight);
                
                let lightPosition1 = new THREE.Vector3(70, 300, -50);
                let lightPosition2 = new THREE.Vector3(-70, 300, -50);
                let directionalLightIntensity = 0.4;
                let directionalLightColour = 0xFFFFFF;
                let shadowFrustum = 50;
                let shadowMapWidth = 1024;
                let shadowMapHeight = 1024;
                let directionalLight1 = new THREE.DirectionalLight(directionalLightColour, directionalLightIntensity);
				let directionalLight2 = new THREE.DirectionalLight(directionalLightColour, directionalLightIntensity);
				directionalLight1.position.set(lightPosition1);
				
                directionalLight1.position.copy(lightPosition1);
                directionalLight1.castShadow = true;
                directionalLight1.shadow.camera.right = shadowFrustum;
                directionalLight1.shadow.camera.left = -shadowFrustum;
                directionalLight1.shadow.camera.top = shadowFrustum;
                directionalLight1.shadow.camera.bottom = -shadowFrustum;
                directionalLight1.shadow.mapSize.width = shadowMapWidth;
                directionalLight1.shadow.mapSize.height = shadowMapHeight;
                scene.add(directionalLight1);
				
//				directionalLight2.position.copy(lightPosition2);
//                directionalLight2.castShadow = true;
//                directionalLight2.shadow.camera.right = shadowFrustum;
//                directionalLight2.shadow.camera.left = -shadowFrustum;
//                directionalLight2.shadow.camera.top = shadowFrustum;
//                directionalLight2.shadow.camera.bottom = -shadowFrustum;
//                directionalLight2.shadow.mapSize.width = shadowMapWidth;
//                directionalLight2.shadow.mapSize.height = shadowMapHeight;
//                scene.add(directionalLight2);
//                
//                const cubeTextureLoader = new THREE.CubeTextureLoader();
//				cubeTextureLoader.setPath( 'skybox/' );
//
//				const cubeTexture = cubeTextureLoader.load( [
//					"wrath_ft.jpg", "wrath_bk.jpg",
//					"wrath_up.jpg", "wrath_dn.jpg",
//					"wrath_rt.jpg", "wrath_lf.jpg"
//				] );
//
//				scene.background = cubeTexture;
                
                gameBoard = new GameBoard();
				moveManager = new MoveManager(gameBoard, 0, false);
				camera.position.set(600, 510, gameBoard.graphics.getCenter().z)
                
				// Debug Sphere
//				var geometry = new THREE.SphereGeometry( 5, 32, 32 );
//				var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
//				var sphere = new THREE.Mesh( geometry, material );
//				sphere.position.set(getCenterPoint(gameBoard.graphics.mesh));
//				scene.add( sphere );
				
				
            }
            
            function rotateObject(object, degreeX=0, degreeY=0, degreeZ=0) {
                object.rotateX(THREE.Math.degToRad(degreeX));
                object.rotateY(THREE.Math.degToRad(degreeY));
                object.rotateZ(THREE.Math.degToRad(degreeZ));
            }
            
            // Initialize the mouse controls provided by:
            // https://threejs.org/examples/misc_controls_trackball.html
            function initControls(){

                controls = new THREE.TrackballControls( camera, renderer.domElement );

                controls.rotateSpeed = 1.8; // set rotation/zoom/pan speeds
                controls.zoomSpeed = 1.5;
                controls.panSpeed = 0.45;

                controls.noZoom = false; // enable zooming, panning, and smooth panning
                controls.noPan = false;
                controls.staticMoving = false;

                controls.dynamicDampingFactor = 0.2; // set dampening factor
                controls.minDistance = 100
                controls.maxDistance = 2250
                
				const target = gameBoard.graphics.getCenter();
                controls.target.set(target.x, target.y, target.z);
				
				var geometry = new THREE.SphereGeometry( 5, 32, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0xff0000, transparent:true, opacity:0.0} );
				debugSphere = new THREE.Mesh( geometry, material );
				debugSphere.position.set(controls.target.x, controls.target.y, controls.target.z);
				scene.add( debugSphere );
				
				window.addEventListener( 'resize', onWindowResize, false );
				function onWindowResize(){
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
				}

            }

            let last = 0;
            let now = window.performance.now();
            let dt;
            let accumulation = 0;
            const step = 1/60; // update simulation every 1/60 of a second (60 fps)

            function frame() {

                now = window.performance.now(); // store the time when the new frame starts
                dt = now - last; // calculate the amount of time the last frame took
                accumulation += Math.min(1, dt/1000);	// increase accumulation by the amount of time the last frame took and limit accumulation time to 1 second.

                keyInputs(); // update mouse input

                // if the accumulated time is larger than the fixed time-step, continue to
                // update the simulation until it is caught up to real time
                while(accumulation >= step){

                    update(); // update the simulation
                    accumulation -= step;

                }

                // render the scene
                render(scene, camera);

                last = now;
                requestAnimationFrame(frame); // repeat the loop
            }








            // update mouse controls
            function keyInputs(){

                controls.update();
//				debugSphere.position.set(0, controls.target.y, controls.target.z);
				debugSphere.position.set(controls.target.x, controls.target.y, controls.target.z);
                pointer.keyInputs(scene, camera, gameBoard)

            }

            // update the simulation
            function update(){



            }

            // Render the simulation
            function render(scene, camera){
				
                if(animationQueue.length > 0){
//                    console.log(animationQueue[0])
                    animationQueue[0].onAnimate()
                    animationQueue[0].execute()
                    animationQueue.shift()
                }
                
                
                
                // Render the scene using functionality provided by the three.js library
                // https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene
                renderer.render(scene, camera);

            }


            // Function getRandomIntenger returns a random integer between lowerBound (inclusive) and upperBound (inclusive)
            function getRandomInteger(lowerBound, upperBound){

                //          [0, 1)                range                     
                return Math.floor(Math.random() * (upperBound - lowerBound) + lowerBound);

            }
            
			function mayn(){
//				var text2 = document.createElement('div');
//				text2.style.position = 'absolute';
//				//text2.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
//				text2.style.width = 100;
//				text2.style.height = 100;
//				text2.style.backgroundColor = "blue";
//				text2.innerHTML = "hi there!";
//				text2.style.top = 200 + 'px';
//				text2.style.left = 200 + 'px';
//				document.body.appendChild(text2);
			}
			
        </script>
		
		<style>
			/* Prevent Scrolling */
			html, body { 
			  overflow-x: hidden;
			  overflow-y: hidden;
			}
			body {
			  position: relative;
			}
/*
			#button {
				position: fixed;
				bottom: 16px;
				right: 16px;
				padding: 10px;
				border-radius: 50%;
				margin-bottom: 0px;
				background-color: #FFF;
				opacity: .9;
				z-index: 999;
				box-shadow: 0 0 4px rgba(0,0,0,.15);
			}
*/
		</style>
        
	</head>
    <body>
<!--		<a id="button" target="_blank"  style="position: absolute;"><img src="./icons/arrow_forward_ios-24px.svg"></a>-->
<!--		<a id="button" target="_blank"  style="position: absolute;"><img src="./icons/arrow_back_ios-24px.svg"></a>-->
    </body>
    
</html>      