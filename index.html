<!DOCTYPE html>
<html>
	<head>
        
		<title>4D Chess</title>
		<!--	Disable Zoom on mobile	-->
		<meta name="viewport" content="width=device-width, user-scalable=no">
        
<!--        <script src="/socket.io/socket.io.js"></script>-->
		<link href="https://fonts.googleapis.com/css?family=Roboto+Mono|Source+Code+Pro|Ubuntu+Mono&display=swap" rel="stylesheet">
        <script src="js/three.js"></script>
        <script src="js/TrackballControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/Models.js"></script>
        <script src="js/GameBoard.js"></script>
		<script src="js/MoveManager.js"></script>
        <script src="js/Piece.js"></script>
        <script src="js/Pointer.js"></script>
        <script src="js/Animation.js"></script>
		<script src="js/ClientStateManager.js"></script>
		<script src="js/ClientState.js"></script>
		<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
  		<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
		<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
		<script src="https://unpkg.com/@material-ui/core@4.9.5/umd/material-ui.development.js"></script>
		
		<script src="js/lodash.js"></script>
		
		<link rel="stylesheet" type="text/css" href="css/style.css">
        
        <script type="text/babel">


			/**
			 * TODO BEFORE PRODUCTION BUILD: 
				- Replace all CDNs
				BUGS:
				- work on Piece.update -- undoing a pawn's hasMoved/justMovedTwoSpaces does not undo the state.
			 */
//            try {
//				const socket = io()
//			socket.emit('HW message', 'hello from html!')
//			} catch(err) {
//				console.warn('Socket.io lib not found')
//			}        
			window.onload = function(){
                if(Detector.webgl){
					main();
                } else {
                    var warning = Detector.getWebGLErrorMessage();
                    document.getElementById('container').appendChild(warning);
                }
            };

            // declare global variables
			const SERVER = false;
            let scene;
            let camera;
            let renderer;
            let controls;
			let backendBoard;
			let backendMoveManager;
            let gameBoard;
			let moveManager;
            let pointer;
            let animationQueue = []
			let debugSphere;
			let stateManager = new ClientStateManager(SERVER ? ClientState.SERVER : ClientState.MENU);
			let uiProxy;
			

			function main() {
				const modelLoadProm = Models.loadModels();
				modelLoadProm.then(init, function() {
					console.error("Could not load models.");
				});
			}

            function init(){
                initTHREE();
                initControls();
				initGameBoard();
                initPointer();
				initReact();
                // begin the simulation loop
                requestAnimationFrame(frame);
            }

			function initReact() {
//				uiProxy = SERVER ? new EmptyUI() : new UI();
				uiProxy = new EmptyUI(); // will be changed when component mounts
				ReactDOM.render(
				  <App />,
				  document.getElementById('gui')
				);
			}

			function initGameBoard() {
				
				backendBoard = new GameBoard(4, EmptyBoardGraphics);
				backendMoveManager = new MoveManager(backendBoard, 0, MoveManager.SANDBOX, false);
				gameBoard = new GameBoard(4, SERVER ? EmptyBoardGraphics : BoardGraphics);
				moveManager = new MoveManager(gameBoard, 0, MoveManager.SANDBOX, true);
				
				
				if (SERVER) {
					return;
				}
				
				camera.position.set(600, 510, gameBoard.graphics.getCenter().z)
				const target = gameBoard.graphics.getCenter();
                controls.target.set(target.x, target.y, target.z);
				
				let coolPos = {x: 555.8170713338144, y: 506.7444028015284 + 110, z: -420}
				let coolTar = {x: 0, y: 262.5 + 110, z: -420}
				camera.position.set(coolPos.x, coolPos.y, coolPos.z);
				controls.target.set(coolTar.x, coolTar.y, coolTar.z);
				
				debugSphere = DEBUG(controls.target, 0, 0);
				
//				let boundingBox = gameBoard.graphics.getBoundingBox();
//				DEBUG(boundingBox.bottomLeft);
//				DEBUG(boundingBox.topRight);
			}

            function initTHREE(){
				
				if (SERVER) {
					return;
				}

                // Code from three.js scene creation example.
                // https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene
                scene = new THREE.Scene(); // Create new scene
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 9000); 
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.domElement.id = "myCanvas"
                document.body.appendChild(renderer.domElement);

                renderer.setClearColor(0xf7f7f7);
                // Code from three.js ambient light example:
                // https://threejs.org/docs/index.html#api/lights/AmbientLight
                let ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
                scene.add(ambientLight);
                
                let lightPosition1 = new THREE.Vector3(70, 300, -50);
                let lightPosition2 = new THREE.Vector3(-70, 300, -50);
                let directionalLightIntensity = 0.4;
                let directionalLightColour = 0xFFFFFF;
                let shadowFrustum = 50;
                let shadowMapWidth = 1024;
                let shadowMapHeight = 1024;
                let directionalLight1 = new THREE.DirectionalLight(directionalLightColour, directionalLightIntensity);
				let directionalLight2 = new THREE.DirectionalLight(directionalLightColour, directionalLightIntensity);
				directionalLight1.position.set(lightPosition1);
				
                directionalLight1.position.copy(lightPosition1);
                directionalLight1.castShadow = true;
                directionalLight1.shadow.camera.right = shadowFrustum;
                directionalLight1.shadow.camera.left = -shadowFrustum;
                directionalLight1.shadow.camera.top = shadowFrustum;
                directionalLight1.shadow.camera.bottom = -shadowFrustum;
                directionalLight1.shadow.mapSize.width = shadowMapWidth;
                directionalLight1.shadow.mapSize.height = shadowMapHeight;
                scene.add(directionalLight1);
				
				window.addEventListener( 'resize', onWindowResize, false );
				function onWindowResize(){
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
					controls.handleResize();
				}
            }
            
            function rotateObject(object, degreeX=0, degreeY=0, degreeZ=0) {
                object.rotateX(THREE.Math.degToRad(degreeX));
                object.rotateY(THREE.Math.degToRad(degreeY));
                object.rotateZ(THREE.Math.degToRad(degreeZ));
            }
            
            // Initialize the mouse controls provided by:
            // https://threejs.org/examples/misc_controls_trackball.html
            function initControls(){

				if (SERVER) {
					return;
				}
				
                controls = new THREE.TrackballControls( camera, renderer.domElement );

                controls.rotateSpeed = 1.8; // set rotation/zoom/pan speeds
                controls.zoomSpeed = 1.5;
                controls.panSpeed = 0.45;

                controls.noZoom = false; // enable zooming, panning, and smooth panning
                controls.noPan = false;
                controls.staticMoving = false;

                controls.dynamicDampingFactor = 0.2; // set dampening factor
                controls.minDistance = 100
                controls.maxDistance = 1400
            }

            let last = 0;
            let now = window.performance.now();
            let dt;
            let accumulation = 0;
            const step = 1/60; // update simulation every 1/60 of a second (60 fps)

            function frame() {

                now = window.performance.now(); // store the time when the new frame starts
                dt = now - last; // calculate the amount of time the last frame took
                accumulation += Math.min(1, dt/1000);	// increase accumulation by the amount of time the last frame took and limit accumulation time to 1 second.

                stateManager.keyInputs(); // update mouse input

                // if the accumulated time is larger than the fixed time-step, continue to
                // update the simulation until it is caught up to real time
                while(accumulation >= step){

                    stateManager.update(); // update the simulation
                    accumulation -= step;

                }

                // render the scene
                stateManager.render(scene, camera);

                last = now;
                requestAnimationFrame(frame); // repeat the loop
            }


            // Function getRandomIntenger returns a random integer between [lowerBound, upperBound]
            function getRandomInteger(lowerBound, upperBound){
                //          [0, 1)                range                     
                return Math.floor(Math.random() * (upperBound - lowerBound) + lowerBound);
            }

			function rotateCameraAbout(camera, center, theta) {
				camera.position.sub(center);
				let x = camera.position.x,
					y = camera.position.y,
					z = camera.position.z;
				camera.position.x = x * Math.cos(theta) + z * Math.sin(theta);
    			camera.position.z = z * Math.cos(theta) - x * Math.sin(theta);
				camera.position.add(center);
			}
			
			function DEBUG(pos, color=0xff0000, opacity=0.5) {
				const geometry = new THREE.SphereGeometry( 5, 32, 32 );
				const material = new THREE.MeshBasicMaterial({color: color, transparent:true, opacity: opacity});
				const DEBUG_SPHERE = new THREE.Mesh(geometry, material);
				DEBUG_SPHERE.position.set(pos.x, pos.y, pos.z);
				scene.add(DEBUG_SPHERE);
				return DEBUG_SPHERE;
			}

			function removeEntity(objectName, scene=scene) {
				var selectedObject = scene.getObjectByName(objectName.name);
				scene.remove(selectedObject);
			}

			function eq(a, b) {
				return _.reduce(a, function(result, value, key) {
					return _.isEqual(value, b[key]) ?
						result : result.concat(key);
				}, []);
			}
			/*
			 * Compare two objects by reducing an array of keys in obj1, having the
			 * keys in obj2 as the intial value of the result. Key points:
			 *
			 * - All keys of obj2 are initially in the result.
			 *
			 * - If the loop finds a key (from obj1, remember) not in obj2, it adds
			 *   it to the result.
			 *
			 * - If the loop finds a key that are both in obj1 and obj2, it compares
			 *   the value. If it's the same value, the key is removed from the result.
			 */
			function getObjectDiff(obj1, obj2) {
				const diff = Object.keys(obj1).reduce((result, key) => {
					if (!obj2.hasOwnProperty(key)) {
						result.push(key);
					} else if (_.isEqual(obj1[key], obj2[key])) {
						const resultKeyIndex = result.indexOf(key);
						result.splice(resultKeyIndex, 1);
					}
					return result;
				}, Object.keys(obj2));

				return diff;
			}

			var compare = function (a, b) {

			  var result = {
				different: [],
				missing_from_first: [],
				missing_from_second: []
			  };

			  _.reduce(a, function (result, value, key) {
				if (b.hasOwnProperty(key)) {
				  if (_.isEqual(value, b[key])) {
					return result;
				  } else {
					if (typeof (a[key]) != typeof ({}) || typeof (b[key]) != typeof ({})) {
					  //dead end.
					  result.different.push(key);
					  return result;
					} else {
					  var deeper = compare(a[key], b[key]);
					  result.different = result.different.concat(_.map(deeper.different, (sub_path) => {
						return key + "." + sub_path;
					  }));

					  result.missing_from_second = result.missing_from_second.concat(_.map(deeper.missing_from_second, (sub_path) => {
						return key + "." + sub_path;
					  }));

					  result.missing_from_first = result.missing_from_first.concat(_.map(deeper.missing_from_first, (sub_path) => {
						return key + "." + sub_path;
					  }));
					  return result;
					}
				  }
				} else {
				  result.missing_from_second.push(key);
				  return result;
				}
			  }, result);

			  _.reduce(b, function (result, value, key) {
				if (a.hasOwnProperty(key)) {
				  return result;
				} else {
				  result.missing_from_first.push(key);
				  return result;
				}
			  }, result);

			  return result;
			}
			
        </script>
		
        
	</head>
    <body>
		<div id="gui" class="overlay"></div>
<!--
		<div id="gui" class="overlay">
			<a class="button" id="redoButton" onclick="moveManager.redo();"><img src="./icons/arrow_forward_ios-24px.svg"></a>
			<a class="button" id="undoButton" onclick="moveManager.undo();"><img src="./icons/arrow_back_ios-24px.svg"></a>
		</div>
-->
		<script type="text/babel">

			function EmptyUI() {
				this.setState = function(state) {
					
				}
			}

			function UI(reactComponent) {
				this._ui = reactComponent;
				this.setState = function(state) {
//					console.log(state)
					this._ui.setState(state);
				}
			}

			class App extends React.Component {
				
				constructor(props) {
					super(props);
					this.state = {menu: true};
					this.swapState = this.swapState.bind(this)
					this.exitMenu = this.exitMenu.bind(this)
				}
				
				swapState(clientState) {
					console.log("App.swapState called")
					if (clientState == ClientState.GAME_STATE) {
						this.setState({
							menu: false
						});
					} else if(clientState == ClientState.MENU) {
						this.setState({
							menu: true
						});
					}
					stateManager.swapState(clientState);
				}
				
				exitMenu() {
					this.swapState(ClientState.GAME_STATE);
				}
				
				render() {
					return this.state.menu ? this.menu() : this.game();
				}
				
				menu() {
					return (
						<div className="overlay">
							<h1 className="text" id="gameTitle">4D Chess </h1>
							<h1 className="text" id="gameSubTitle"> (Offline) </h1>
							<PlayButton id="playButton" text="Play" handleClick={this.exitMenu}/>
							<PlayButton id="privateRoomButton" text="Create Private Game"/>
						</div>
					);
				}
				
				game() {
					return (
						<div className="overlay">
							<div id="toolbar">
								<UndoButton/>
								<MoveStatus ref={(ourComponent) => {uiProxy = new UI(ourComponent)}}></MoveStatus>
								<RedoButton/>
							</div>
						</div>
					);
				}
			}

			class MoveStatus extends React.Component {
				constructor(props) {
					super(props)
					this.state = {
						mostRecentMove: true,
						turn: 0,
						whoseTurn: 0,
						totalMoves: 0,
						mode: 0
					}
					
					moveManager.updateUI();
				}
				
				render() {
					return (
						<div id="moveStatus" className="text toolbarItem">
							{this.state.mode == MoveManager.SANDBOX ?
								this.turnString() :
								this.state.mostRecentMove ? 
									(this.state.whoseTurn === 0 ? "White to Move" : "Black to Move") :
									this.turnString()
							}
						</div>
					)
				}
				
				turnString() {
					return ("Move " + this.state.turn + "/" + this.state.totalMoves);
				}
			}

			class RectMenuButton extends React.Component {
				constructor(props) {
					super(props)
				}
				
				render() {
					return (<button onClick={this.handleClick} className="text rectButton" id={this.id}>
								{this.text}
							</button>)
				}
			}

			class PlayButton extends RectMenuButton {
				constructor(props) {
					super(props)
					this.handleClick = this.props.handleClick;
					this.text = this.props.text;
					this.id = this.props.id;
				}
			}

			class MoveHistoryButton extends React.Component {
				construcor(props) {
					this.state = {};
				}

				render() {
					return (
						<a onClick={this.handleClick} className="moveHistoryButton toolbarItem" id={this.id}>
							<img src={this.imgSrc}/>
						</a>
					);
				}
			}

			class RedoButton extends MoveHistoryButton {
				constructor(props) {
					super(props);
					this.imgSrc = "./icons/arrow_forward_ios-24px.svg"
					this.id = "redoButton";
					
					this.handleClick = this.handleClick.bind(this);
				}

				handleClick() {
					moveManager.redo();
				}
			}

			class UndoButton extends MoveHistoryButton {
				constructor(props) {
					super(props);
					this.id = "undoButton";
					this.imgSrc = "./icons/arrow_back_ios-24px.svg";
					
					this.handleClick = this.handleClick.bind(this);
				}

				handleClick() {
					moveManager.undo();
				}
			}

		</script>
	</body>
    
</html>      