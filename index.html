<!DOCTYPE html>
<html>
	<head>
        
		<title>4D Chess</title>
        
        <script src="js/three.js"></script>
        <script src="js/TrackballControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/itemData.js"></script>
        <script src="js/models.js"></script>
        
        <script>
        
            // when the window loads, execute the function named 'init', which initalizes the simulation
            window.onload = function(){

                if(Detector.webgl){

                    init();
                    requestAnimationFrame(frame);

                } else {

                    var warning = Detector.getWebGLErrorMessage();
                    document.getElementById('container').appendChild(warning);

                }

            };

            // declare global variables
            let scene;
            let camera;
            let renderer;
            let controls;

            function init(){
                
                initTHREE();
                initControls();
                
                // begin the simulation loop
                requestAnimationFrame(frame);

            }

            //
            // Functionality provided by three.js:
            // 
            function initTHREE(){

                // Code from three.js scene creation example.
                // https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene
                scene = new THREE.Scene(); // Create new scene
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000); 
                camera.position.z = 450;
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

//                renderer.setClearColor(0x9BCEE1)
                renderer.setClearColor(0xffffff)
                // Code from three.js ambient light example:
                // https://threejs.org/docs/index.html#api/lights/AmbientLight
                let ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
                scene.add(ambientLight);
                
                var lightPosition = new THREE.Vector3(25, 30, -50);
                var directionalLightIntensity = 0.4;
                var directionalLightColour = 0xFFFFFF;
                var shadowFrustum = 50;
                var shadowMapWidth = 1024;
                var shadowMapHeight = 1024;
                var directionalLight = new THREE.DirectionalLight(directionalLightColour, directionalLightIntensity);
                directionalLight.position.copy(lightPosition);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.right = shadowFrustum;
                directionalLight.shadow.camera.left = -shadowFrustum;
                directionalLight.shadow.camera.top = shadowFrustum;
                directionalLight.shadow.camera.bottom = -shadowFrustum;
                directionalLight.shadow.mapSize.width = shadowMapWidth;
                directionalLight.shadow.mapSize.height = shadowMapHeight;
                scene.add(directionalLight);
                
//                // Code from three.js point light example:
//                // https://threejs.org/docs/index.html#api/lights/PointLight
//                let pointLight = new THREE.PointLight(0xffffff, 1.75);
//                pointLight.position.set(lightPosition);
//                scene.add(pointLight);

                
                let size = 6;
                let bottom = -30;
                let left = -575;
//                let increment = 96 / size;
                let verticalIncrement = 200 / size;
                let horizontalIncrement = 150
                
                for (let w = 0; w < size; w++){
                    for(let i = 0; i < size; i++){
                        let checker = checkerboard(size, z=i, w) // Construct 2D checkerboard planes
                        checker.position.set(0, bottom + i*verticalIncrement, left + w*horizontalIncrement)
                        rotateObject(checker, -90, 0, 0)
                        scene.add(checker)
                    }
                }
                
                
                
                
                
                
                
                const blackMaterial = new THREE.MeshPhongMaterial({
                    color: 0x110C11,
                    reflectivity: 0.1,
                    shininess: 20,
                    shading: THREE.SmoothShading,
                    transparent: true,
                    opacity: 0.9
                });

                const whiteMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFCF6E3,
                    reflectivity: 10,
                    shininess: 25,
                    shading: THREE.SmoothShading,
                    transparent: true,
                    opacity: 0.9
                    
                });
                
                const redMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff0000,
                    reflectivity: 10,
                    shininess: 25,
                    shading: THREE.SmoothShading,
                    transparent: true,
                    opacity: 0.5
                });
                
                // create loading manager to load in all our models
//                var manager = new THREE.LoadingManager();
//                manager.onLoad = init;
//                var loader = new THREE.JSONLoader(manager);
//                const modelsDirectory = 'models/'
//                
//                items.forEach(item =>{
//                    loader.load(modelsDirectory + item.model, function(geometry, materials) {
//                        var material = item.board ? new THREE.MeshFaceMaterial(materials) :
//                                item.black ? redMaterial : whiteMaterial;
//                        var obj = new THREE.Mesh(geometry, material);
//                        obj.position.set(item.position.x, item.position.y, item.position.z);
//                        obj.rotation.set(THREE.Math.degToRad(item.rotation.x), THREE.Math.degToRad(item.rotation.y),
//                            THREE.Math.degToRad(item.rotation.z));
//                        obj.castShadow = true;
//                        obj.receiveShadow = true;
//                        
//                        obj.scale.set(4, 4, 4)
//                        scene.add(obj);
//                    });
//                });
//                
//                
            }

            function checkerboard(segments=8, z=0, w=0, opacity=0.5){
                let geometry = new THREE.PlaneGeometry(100, 100, segments, segments)
                let materialEven = new THREE.MeshBasicMaterial({color: 0xccccfc})
                let materialOdd = new THREE.MeshBasicMaterial({color: 0x444464})
                let materials = [materialEven, materialOdd]
                
                materials.forEach(m => {
                    m.transparent = true
                    m.opacity = opacity
                    m.side = THREE.DoubleSide;
                })

                let i = j = 0;

                for(let x = 0; x < segments; x++){
                  for(let y = 0; y < segments; y++){
                      i = x * segments + y
                      j = i * 2
                      geometry.faces[j].materialIndex = geometry.faces[j + 1].materialIndex = (x + y + z + w) % 2
                  }
                }

                //
                // THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial
                //
//                    return new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials))
                return new THREE.Mesh(geometry, new THREE.MultiMaterial(materials))
            }
            
            function rotateObject(object, degreeX=0, degreeY=0, degreeZ=0) {
                object.rotateX(THREE.Math.degToRad(degreeX));
                object.rotateY(THREE.Math.degToRad(degreeY));
                object.rotateZ(THREE.Math.degToRad(degreeZ));
            }
            
            
            // Initialize the mouse controls provided by:
            // https://threejs.org/examples/misc_controls_trackball.html
            function initControls(){

                controls = new THREE.TrackballControls( camera, renderer.domElement );

                controls.rotateSpeed = 1.8; // set rotation/zoom/pan speeds
                controls.zoomSpeed = 1.5;
                controls.panSpeed = 0.3;

                controls.noZoom = false; // enable zooming, panning, and smooth panning
                controls.noPan = false;
                controls.staticMoving = false;

                controls.dynamicDampingFactor = 0.25; // set dampening factor
//                controls.maxDistance = 2500

            }

            let last = 0;
            let now = window.performance.now();
            let dt;
            let accumulation = 0;
            const step = 1/60; // update simulation every 1/60 of a second (60 fps)

            function frame() {

                now = window.performance.now(); // store the time when the new frame starts
                dt = now - last; // calculate the amount of time the last frame took
                accumulation += Math.min(1, dt/1000);	// increase accumulation by the amount of time the last frame took and limit accumulation time to 1 second.

                keyInputs(); // update mouse input

                // if the accumulated time is larger than the fixed time-step, continue to
                // update the simulation until it is caught up to real time
                while(accumulation >= step){

                    update(); // update the simulation
                    accumulation -= step;

                }

                // render the scene
                render();

                last = now;
                requestAnimationFrame(frame); // repeat the loop
            }








            // update mouse controls
            function keyInputs(){

                controls.update();

            }

            // update the simulation
            function update(){



            }

            // Render the simulation
            function render(){

                // Render the scene using functionality provided by the three.js library
                // https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene
                renderer.render(scene, camera);

            }


            // Function getRandomIntenger returns a random integer between lowerBound (inclusive) and upperBound (inclusive)
            function getRandomInteger(lowerBound, upperBound){

                //          [0, 1)                range                     
                return Math.random() * (upperBound - lowerBound + 1) + lowerBound;

            }

            // Entity constructor
            function Entity(mesh, appliedForce){

                // initialize body (physics) and mesh (graphics) components
                this.mesh = mesh; // three.js mesh

                world.addBody(this.body);
                scene.add(this.mesh);

            }


            Entity.prototype = {
                

            };
            
            Entity.entities = [];
            
        </script>
        
	</head>
    <body>
    </body>
    
</html>      